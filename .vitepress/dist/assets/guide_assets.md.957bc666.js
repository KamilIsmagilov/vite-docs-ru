import{o as s,c as a,d as n}from"./app.877e1a61.js";const e='{"title":"Обработка статичных ресурсов (Static Asset Handling)","description":"","frontmatter":{},"headers":[{"level":2,"title":"Импортирование ресурсов как URL","slug":"импортирование-ресурсов-как-url"},{"level":3,"title":"Явные URL импорты","slug":"явные-url-импорты"},{"level":3,"title":"Импортирование Asset как String","slug":"импортирование-asset-как-string"},{"level":3,"title":"Импортирование скрипта как Worker","slug":"импортирование-скрипта-как-worker"},{"level":2,"title":"Директория public","slug":"директория-public"},{"level":2,"title":"new URL(url, import.meta.url)","slug":"new-url-url-import-meta-url"}],"relativePath":"guide/assets.md","lastUpdated":1631747407540}',t={},o=[n('<h1 id="обработка-статичных-ресурсов-static-asset-handling" tabindex="-1">Обработка статичных ресурсов (Static Asset Handling) <a class="header-anchor" href="#обработка-статичных-ресурсов-static-asset-handling" aria-hidden="true">#</a></h1><ul><li>Связанный раздел: <a href="./build.html#public-base-path">Public Base Path</a></li><li>Связанный раздел: <a href="/config/#assetsinclude"><code>assetsInclude</code> config option</a></li></ul><h2 id="импортирование-ресурсов-как-url" tabindex="-1">Импортирование ресурсов как URL <a class="header-anchor" href="#импортирование-ресурсов-как-url" aria-hidden="true">#</a></h2><blockquote><p>Примечание переводчика. Далее в документации термин &quot;asset&quot; и ресурсы взаимозаменяем. В устной речи разработчики чаще пользуются английским словом, чем &quot;ресурсы&quot;</p></blockquote><p>Импортирование статических ресурсов вернёт правильный public URL, когда он будет запрошен:</p><div class="language-js"><pre><code><span class="token keyword">import</span> imgUrl <span class="token keyword">from</span> <span class="token string">&#39;./img.png&#39;</span>\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;hero-img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> imgUrl\n</code></pre></div><p>Например, <code>imgUrl</code> станет строкой <code>/img.png</code> во время разработки (dev build), и строкой <code>/assets/img.2d8efhg.png</code> в production сборке.</p><p>Это поведение очень похоже на <code>file-loader</code> в webpack. Различие только в том, что импорт может быть использован как с абсолютным путём (основываясь на вашей корневой директории во время разработки), так и с относительным путём (relative path).</p><ul><li><p><code>url()</code> ссылки в CSS обрабатываются таким же образом.</p></li><li><p>Если Вы используете Vue plugin, ссылки на assets во Vue SFC шаблонах автоматически конвертируются в импорты.</p></li><li><p>Общеиспользуемые форматы картинок, медиа, и шрифтов распознаются как assets автоматически. Вы можете расширить этот внутренний список используя <a href="/config/#assetsinclude"><code>assetsInclude</code> option</a>.</p></li><li><p>Ресурсы, на которые есть ссылки, встраиваются как часть графа assets (build assets graph), у них будут хэшированные имена файлов и они могут обрабатываться плагинами для их оптимизации.</p></li><li><p>Assets размеры которых в байтах меньше чем <a href="/config/#build-assetsinlinelimit"><code>assetsInlineLimit</code> option</a> будут вставлены инлайном как base64 data URL.</p></li></ul><h3 id="явные-url-импорты" tabindex="-1">Явные URL импорты <a class="header-anchor" href="#явные-url-импорты" aria-hidden="true">#</a></h3><p>Ресурсы, формат которых не включен во внутренний список или в <code>assetsInclude</code> могут быть явно импортированы как URL используя суффикс <code>?url</code>. Это пригодится, например, для импорта <a href="https://houdini.how/usage" target="_blank" rel="noopener noreferrer">Houdini Paint Worklets</a>.</p><div class="language-js"><pre><code><span class="token keyword">import</span> workletURL <span class="token keyword">from</span> <span class="token string">&#39;extra-scalloped-border/worklet.js?url&#39;</span>\n<span class="token constant">CSS</span><span class="token punctuation">.</span>paintWorklet<span class="token punctuation">.</span><span class="token function">addModule</span><span class="token punctuation">(</span>workletURL<span class="token punctuation">)</span>\n</code></pre></div><h3 id="импортирование-asset-как-string" tabindex="-1">Импортирование Asset как String <a class="header-anchor" href="#импортирование-asset-как-string" aria-hidden="true">#</a></h3><p>Ресурсы могут быть импортированы как строки с помощью суффикса <code>?raw</code>.</p><div class="language-js"><pre><code><span class="token keyword">import</span> shaderString <span class="token keyword">from</span> <span class="token string">&#39;./shader.glsl?raw&#39;</span>\n</code></pre></div><h3 id="импортирование-скрипта-как-worker" tabindex="-1">Импортирование скрипта как Worker <a class="header-anchor" href="#импортирование-скрипта-как-worker" aria-hidden="true">#</a></h3><p>Скрипты могут быть импортированы как web worker&#39;ы с суффиксами <code>?worker</code> или <code>?sharedworker</code>.</p><div class="language-js"><pre><code><span class="token comment">// Отдельный chunk в production сборке</span>\n<span class="token keyword">import</span> Worker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?worker&#39;</span>\n<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// sharedworker</span>\n<span class="token keyword">import</span> SharedWorker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?sharedworker&#39;</span>\n<span class="token keyword">const</span> sharedWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// Инлайном как base64 строка</span>\n<span class="token keyword">import</span> InlineWorker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?worker&amp;inline&#39;</span>\n</code></pre></div><p>Ознакомьтесь с разделом <a href="./features.html#web-workers">Web Worker</a> для более детальной информации.</p><h2 id="директория-public" tabindex="-1">Директория <code>public</code> <a class="header-anchor" href="#директория-public" aria-hidden="true">#</a></h2><p>Если у вас есть assets, которые:</p><ul><li>Никогда не используются в исходном коде (например, <code>robots.txt</code>)</li><li>Должны содержать конкретное имя файла (без хеширования)</li><li>...или вы просто не хотите сначала импортировать ресурс, чтобы только получить его URL (если вам нужен только URL ресурса)</li></ul><p>Тогда вы можете разместить ресурс в специальной директории <code>public</code> в вашем корневом каталоге. Assets в этой директории будут сёрвиться через корневой путь <code>/</code> во время dev разработки и будут скопированы в <code>dist</code> директорию корневого каталога как есть.</p><p>По умолчанию используется директория <code>&lt;root&gt;/public</code>, но вы можете настроить это через <a href="/config/#publicdir"><code>publicDir</code> option</a>.</p><p>Обратите внимание:</p><ul><li>Вы всегда должны ссылаться на ресурсы <code>public</code> используя абсолютный рутовый путь - например, ссылка на файл <code>public/icon.png</code> должна быть такой ссылкой в исходном коде <code>/icon.png</code>.</li><li>Assets в <code>public</code> не могут быть импортированы в JavaScript.</li></ul><h2 id="new-url-url-import-meta-url" tabindex="-1">new URL(url, import.<wbr>meta.url) <a class="header-anchor" href="#new-url-url-import-meta-url" aria-hidden="true">#</a></h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.&lt;wbr/&gt;meta" target="_blank" rel="noopener noreferrer">import.<wbr>meta.url</a> это нативная ESM фича, которая предоставляет URL адрес текущего модуля. Объединив это с нативным <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" target="_blank" rel="noopener noreferrer">URL constructor</a>, мы можем получить полный, резолвнутый (resolved) URL статического asset используя относительный путь из JavaScript модуля:</p><div class="language-js"><pre><code><span class="token keyword">const</span> imgUrl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">&#39;./img.png&#39;</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span>\n\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;hero-img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> imgUrl\n</code></pre></div><p>Это работает нативно в современных браузерах - на самом деле, Vite&#39;у вовсе не обязательно обрабатывать этот код на протяжении всего процесса разработки!</p><p>Этот pattern также поддерживает динамичные URL через шаблонные строки (template literals):</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">getImageUrl</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./dir/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.png</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>href\n<span class="token punctuation">}</span>\n</code></pre></div><p>Во время production сборки, Vite будет выполнять необходимые трансформации, чтобы URL адреса всё ещё указывали на правильное местонахождение файлов, даже после сборки и хеширования ресурсов.</p><div class="warning custom-block"><p class="custom-block-title">Note: Не используйте это с SSR</p><p>Этот паттерн не сработает, если Вы используете Vite для Server-Side rendering&#39;а, потому что <code>import.<wbr>meta.url</code> имеет различную семантику в браузерах и Node.js. Сервер сборка также не может заранее определить URL адресс хоста клиента.</p></div>',36)];t.render=function(n,e,t,p,r,l){return s(),a("div",null,o)};export{e as __pageData,t as default};
