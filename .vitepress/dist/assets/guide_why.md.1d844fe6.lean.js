import{o as e,c as l,a as n,b as r}from"./app.877e1a61.js";const t='{"title":"Почему Vite","description":"","frontmatter":{},"headers":[{"level":2,"title":"Проблемы","slug":"пробnемы"},{"level":3,"title":"Медленный старт сервера","slug":"медnенный-старт-сервера"},{"level":3,"title":"Медленные обновления","slug":"медnенные-обновnения"},{"level":2,"title":"Зачем нужен Bundle для Production","slug":"зачем-нужен-bundle-дnя-production"},{"level":2,"title":"Почему бы не использовать Bundle с esbuild?","slug":"почему-бы-не-испоnьзовать-bundle-с-esbuild"},{"level":2,"title":"Чем Vite отличается от X?","slug":"чем-vite-отnичается-от-x"}],"relativePath":"guide/why.md","lastUpdated":1631745764054}',a={},i=[n("h1",{id:"почему-vite",tabindex:"-1"},[r("Почему Vite "),n("a",{class:"header-anchor",href:"#почему-vite","aria-hidden":"true"},"#")],-1),n("h2",{id:"пробnемы",tabindex:"-1"},[r("Проблемы "),n("a",{class:"header-anchor",href:"#пробnемы","aria-hidden":"true"},"#")],-1),n("p",null,'До того как ES модули стали доступными в браузерах, у разработчиков не было нативного механизма для разработки настоящих модулей JavaScript. Поэтому мы с вами все знакомы с концепцией "сборки" (bundling): использование инструментов для сканирования, обработки и объединения всех исходных кодов наших модулей в файлы, которые могут работать в браузере.',-1),n("p",null,[r("Со временем появились такие инструменты как "),n("a",{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer"},"webpack"),r(", "),n("a",{href:"https://rollupjs.org",target:"_blank",rel:"noopener noreferrer"},"Rollup"),r(" и "),n("a",{href:"https://parceljs.org/",target:"_blank",rel:"noopener noreferrer"},"Parcel"),r(", которые значительно улучшили процесс разработки для frontend разработчиков.")],-1),n("p",null,'Однако по мере того, как мы начинаем создавать все более и более амбициозные приложения, количество JavaScript, с которым мы имеем дело, также увеличивалось в геометрической прогрессии. Крупные проекты нередко содержат тысячи модулей. Появляется "бутылочное горлышко" (узкое место) для производительности JavaScript модулей: чтобы запустить dev server, часто может потребоваться неоправданно большое количество времени (иногда этот процесс превышает минуты!) и даже с использованием HMR (Hot Module Replacement для применения изменений без перезагрузки страницы) изменение файла может занять пару секунд прежде чем сами изменения сработают в браузере. Медленный цикл обратной связи с разрабатываемым сайтом может сильно повлиять на продуктивность и настроение разработчиков.',-1),n("p",null,"Vite стремится решить эти проблемы, используя новейшие разработки в экосистеме: доступность использования нативных ES модулей в браузере (современные браузеры поддерживают ES модули) и появление JavaScript инструментов написанных на compile-to-native языках.",-1),n("h3",{id:"медnенный-старт-сервера",tabindex:"-1"},[r("Медленный старт сервера "),n("a",{class:"header-anchor",href:"#медnенный-старт-сервера","aria-hidden":"true"},"#")],-1),n("p",null,'При холодном запуске "cold-starting" dev сервера bundler-based сборщик должен быстро просканировать все зависимости и собрать всё ваше приложение до того как сами файлы станут доступны на запущенном сервере.',-1),n("p",null,[r("Vite улучшает скорость запуска dev сервера, с помощью разделения всех модулей в приложении на две категории: "),n("strong",null,"dependencies"),r(" (зависимости) and "),n("strong",null,"source code"),r(" (исходный код).")],-1),n("ul",null,[n("li",null,[n("p",null,[n("strong",null,"Dependencies"),r(" (зависимости) в основном представляют собой чистый JavaScript, который часто не изменяется в процессе разработки. Некоторые большие зависимости (такие, как библиотеки компонентов с сотнями модулей) также довольно затратны для их обработки. Зависимости могут предоставляться в различных форматах модулей (например, ESM или CommonJS).")]),n("p",null,[r("Vite "),n("a",{href:"./dep-pre-bundling.html"},"pre-bundles dependencies"),r(" (предварительная сборка зависимостей) использует "),n("a",{href:"https://esbuild.github.io/",target:"_blank",rel:"noopener noreferrer"},"esbuild"),r(". Esbuild написан на Go и собирает зависимости в 10-100 раз быстрее, чем сборщики написанные на JavaScript.")])]),n("li",null,[n("p",null,[n("strong",null,"Source code"),r(" (исходный код) часто написан не на чистом JavaScript и нам необходимо трансформировать его (например, JSX, CSS или Vue/Svelte компоненты), и эти файлы будут постоянно редактироваться. Кроме того, нам не нужно постоянно загружать весь исходный код одновременно (как пример, route-based code-splitting - разделение кода на основе роутинга).")]),n("p",null,[r("Vite обрабатывает исходный код с помощью "),n("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer"},"native ESM"),r('. По сути это позволяет браузеру взять на себя часть работы "бандлера" (сборщика пакетов): Vite\'у остаётся только преобразовывать и обрабатывать исходный код по запросу, когда браузер запрашивает это. Код условного динамического импорта обрабатывается только когда он действительно используется на текущем экране.')]),n("p",null,[n("img",{src:"/assets/bundler.37740380.png",alt:"bundler based dev server"})]),n("p",null,[n("img",{src:"/assets/esm.3070012d.png",alt:"esm based dev server"})])])],-1),n("h3",{id:"медnенные-обновnения",tabindex:"-1"},[r("Медленные обновления "),n("a",{class:"header-anchor",href:"#медnенные-обновnения","aria-hidden":"true"},"#")],-1),n("p",null,"Когда файл редактируется в bundler-based сборщике, неэффективно пересобирать всю сборку по очевидным причинам: скорость обновлений будет линейно снижаться в соответствии с размером приложения.",-1),n("p",null,'Некоторые бандлер dev серверы запускают сборку в памяти, поэтому им нужно только убрать часть из "графа" (общего списка зависимостей) когда файл измениться, но всё ещё нужно переконструировать весь собранный bundle и перезагрузить веб страницу. Реконструкция бандла может быть затратной операцией и перезагрузка страницы уничтожает текущее состояние приложения. По этой причине некоторые сборщики "бандлеры" поддерживают Hot Module Replacement (HMR): позволяя модулю самому заменяться на лету "hot replace" (горячая замена) без воздействия на другие части страницы. Это значительно улучшает DX (Developer Experience) - однако, на практике мы обнаружили, что даже скорость обновления HMR сильно ухудшается по мере роста приложения.',-1),n("p",null,"В Vite HMR выполняется поверх собственного ESM. Когда файл редактируется, Vite'у нужно убрать только связь между редактируемым модулем и ближайшей границей HMR (в большинстве случаев только сам модуль), что делает обновления HMR стабильно быстрыми независимо от размера вашего приложения.",-1),n("p",null,[r("Vite также использует заголовки HTTP для ускорения полной перезагрузки страницы (опять же, позволяем браузеру сделать бóльшую работу за нас): модули с исходным кодом запрашиваются через условный "),n("code",null,"304 Not Modified"),r(", и dependency модуль (зависимости) отдаются с жёстким кешом с помощью "),n("code",null,"Cache-Control: max-age=31536000,immutable"),r(", поэтому они больше не обрабатываются сервером, после их кеширования.")],-1),n("p",null,'Как только вы попробуете на сколько Vite быстрый, то вы больше не захотите возвращаться к пакетным "bundle" сборщикам.',-1),n("h2",{id:"зачем-нужен-bundle-дnя-production",tabindex:"-1"},[r("Зачем нужен Bundle для Production "),n("a",{class:"header-anchor",href:"#зачем-нужен-bundle-дnя-production","aria-hidden":"true"},"#")],-1),n("p",null,'Несмотря на то, что нативный ESM в данный момент имеет широкую поддержку браузерами, предоставление несобранного ESM в production всё ещё неэффективна (даже с HTTP/2) из-за дополнительных сетевых циклов, вызванных вложенным импортом. Чтобы получить оптимальную производительность загрузки, всё ещё лучше использовать собранный bundle вашего проекта с tree-shaking, lazy-loading и разделением кода на "чанки" - chunk splitting (для лучшего кеширования).',-1),n("p",null,[r("Обеспечивать оптимальный вывод и согласованность поведения между dev сервером и production сборкой не так-то просто. Поэтому Vite поставляется с pre-configured (преднастроенной) "),n("a",{href:"./build.html"},"build command"),r(", которая из коробки включает в себя многие оптимизации производительности "),n("a",{href:"./features.html#build-optimizations"},"performance optimizations"),r(".")],-1),n("h2",{id:"почему-бы-не-испоnьзовать-bundle-с-esbuild",tabindex:"-1"},[r("Почему бы не использовать Bundle с esbuild? "),n("a",{class:"header-anchor",href:"#почему-бы-не-испоnьзовать-bundle-с-esbuild","aria-hidden":"true"},"#")],-1),n("p",null,[r("Несмотря на то, что "),n("code",null,"esbuild"),r(" быстро развивается и уже является работоспособным сборщиком для многих библиотек, некоторые из важных фич необходимых для сборки приложений всё ещё находятся в стадии разработки - в частности code-splitting (разделение кода) и CSS handling (обработка CSS). На данный момент в этом плане Rollup - более зрелый и гибкий инструмент. Тем не менее мы не исключаем в будущем возможность сборки production build с помощью "),n("code",null,"esbuild"),r(", когда эти фичи будут в стабильной версии.")],-1),n("h2",{id:"чем-vite-отnичается-от-x",tabindex:"-1"},[r("Чем Vite отличается от X? "),n("a",{class:"header-anchor",href:"#чем-vite-отnичается-от-x","aria-hidden":"true"},"#")],-1),n("p",null,[r("Вы можете ознакомиться с "),n("a",{href:"./comparisons.html"},"Comparisons"),r(" секцией для более детального обзора о том, чем Vite отличается от других похожих инструментов.")],-1)];a.render=function(n,r,t,a,d,u){return e(),l("div",null,i)};export{t as __pageData,a as default};
