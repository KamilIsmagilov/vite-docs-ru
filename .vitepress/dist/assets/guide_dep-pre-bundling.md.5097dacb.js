import{o as e,c as d,d as n}from"./app.877e1a61.js";const o='{"title":"Pre-Bundling зависимостей","description":"","frontmatter":{},"headers":[{"level":2,"title":"Почему","slug":"почему"},{"level":2,"title":"Автоматическое обнаружение зависимостей","slug":"автоматическое-обнаружение-зависимостей"},{"level":2,"title":"Монорепы и связанные зависимости (Monorepos and Linked Dependencies)","slug":"монорепы-и-связанные-зависимости-monorepos-and-linked-dependencies"},{"level":2,"title":"Настройка","slug":"настройка"},{"level":2,"title":"Кэширование","slug":"кэширование"},{"level":3,"title":"File System Cache","slug":"file-system-cache"},{"level":3,"title":"Browser Cache","slug":"browser-cache"}],"relativePath":"guide/dep-pre-bundling.md","lastUpdated":1631746739938}',a={},i=[n('<h1 id="pre-bundling-зависимостей" tabindex="-1">Pre-Bundling зависимостей <a class="header-anchor" href="#pre-bundling-зависимостей" aria-hidden="true">#</a></h1><p>Когда вы запускаете <code>vite</code> в первый раз, вы можете увидеть это сообщение:</p><div class="language-"><pre><code>Optimizable dependencies detected:\nreact, react-dom\nPre-bundling them to speed up dev server page load...\n(this will be run only when your dependencies have changed)\n</code></pre></div><h2 id="почему" tabindex="-1">Почему <a class="header-anchor" href="#почему" aria-hidden="true">#</a></h2><p>Vite выполняет то, что мы называем &quot;dependency pre-bundling&quot; (предварительное объединение зависимостей). Этот процесс служит двум целям:</p><ol><li><p><strong>CommonJS и UMD совместимость:</strong> Во время разработки, Vite&#39;s dev обрабатывает весь код как нативный ESM. Следовательно, Vite должен сначала конвертировать зависимости, которые поставляются как CommonJS или UMD в ESM.</p><p>При преобразовании зависимостей CommonJS Vite выполняет интеллектуальный анализ импорта, поэтому именование импорта в модулях CommonJS будет работать должным образом, даже если экспорт назначается динамически (например, React):</p><div class="language-js"><pre><code><span class="token comment">// работает как ожидается</span>\n<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>\n</code></pre></div></li><li><p><strong>Производительность:</strong> Vite конвертирует ESM зависимости со множеством внутренних модулей в один модуль, чтобы улучшить последующую скорость загрузки страниц.</p><p>Некоторые пакеты поставляются как сборка множества отдельных ES модулей, импортирующих друг друга. Например, <a href="https://unpkg.com/browse/lodash-es/" target="_blank" rel="noopener noreferrer"><code>lodash-es</code> имеет более 600 внутренних модулей</a>! Когда мы делаем <code>import { debounce } from &#39;lodash-es&#39;</code>, браузер запускает 600+ HTTP запросов одновременно! Несмотря на то, что у сервера нет проблема с их обработкой, огромное количество запросов создаёт перегрузку сети на стороне браузера, в результате чего страница загружается гораздо медленнее.</p><p>С pre-bundling <code>lodash-es</code> в один модуль, нам нужно сделать только один HTTP запрос!</p></li></ol><h2 id="автоматическое-обнаружение-зависимостей" tabindex="-1">Автоматическое обнаружение зависимостей <a class="header-anchor" href="#автоматическое-обнаружение-зависимостей" aria-hidden="true">#</a></h2><p>Если кеша ещё нет, то Vite проанализирует ваш исходный код и автоматически обнаружит импорт зависимостей (то есть &quot;bare imports&quot;, которые должны браться из <code>node_modules</code>) и будет использовать найденные импорты как точки входа (entry points) для pre-bundle. Pre-bundling осуществляется с помощью <code>esbuild</code>, поэтому всё это происходит очень быстро.</p><p>После того как сервер запущен, если обнаружен новый импорт зависимости (dependency import), который не в кеше, то Vite перезапустит сборку зависимостей (dep bundling process) и перезагрузит страницу.</p><h2 id="монорепы-и-связанные-зависимости-monorepos-and-linked-dependencies" tabindex="-1">Монорепы и связанные зависимости (Monorepos and Linked Dependencies) <a class="header-anchor" href="#монорепы-и-связанные-зависимости-monorepos-and-linked-dependencies" aria-hidden="true">#</a></h2><p>В монорепах, зависимости могут быть связанным пакетом (linked package) того же репо. Vite автоматически находит зависимости, которые берутся не из <code>node_modules</code> и рассматривает их как исходный код. Он не будет пытаться собрать (linked dep) связанную зависимость, вместо этого он будет анализировать список связанных зависимостей.</p><div class="warning custom-block"><p class="custom-block-title">Note</p><p>Связанные зависимости (linked dependencies) могут работать некорректно в финальной сборке из-за различий в разрешении зависимостей (dependency resolution). Вместо этого, используйте <code>npm package</code> для всех локальных зависимостей, чтобы избежать ошибок в финальной сборке.</p></div><h2 id="настройка" tabindex="-1">Настройка <a class="header-anchor" href="#настройка" aria-hidden="true">#</a></h2><p>Дефолтная эвристика для поиска зависимостей не всегда может соответствовать вашим ожиданиям. Если вы хотите явно подключить/отключить зависимости из списка, воспользуйтесь <a href="/config/#dep-optimization-options"><code>optimizeDeps</code> config options</a>.</p><p>Типичный вариант использования <code>optimizeDeps.include</code> или <code>optimizeDeps.exclude</code> - когда у вас есть импорт, который нельзя напрямую обнаружить в исходном коде. Например, может быть этот импорт создаётся как результат трансформации какого-то плагина. Это значит, Vite не сможет найти импорт при начальном сканировании - он может обнаружить импорт только после того, как файл запрошен браузером и трансформирован. Это приведёт к немедленному re-bundle (пересборке) после запуска сервера.</p><p>Оба параметра <code>include</code> и <code>exclude</code> могут быть использованы, чтобы решить этот вопрос. Если зависимость большая (с большим количеством внутренних модулей) или это CommonJS, то Вам следует подключить это (include); Если зависимость маленькая и это уже валидный ESM, вы можете исключить (exclude) это и позволить браузеру загрузить это напрямую.</p><h2 id="кэширование" tabindex="-1">Кэширование <a class="header-anchor" href="#кэширование" aria-hidden="true">#</a></h2><h3 id="file-system-cache" tabindex="-1">File System Cache <a class="header-anchor" href="#file-system-cache" aria-hidden="true">#</a></h3><p>Vite кэширует pre-bundled зависимости в <code>node_modules/.vite</code>. Он определяет нужно ли делать re-run (перезапускать) pre-bundling, основываясь на следующих данных:</p><ul><li>Список зависимостей <code>dependencies</code> в вашем <code>package.json</code></li><li>Package manager lockfiles, например. <code>package-lock.json</code>, <code>yarn.lock</code>, или <code>pnpm-lock.yaml</code>.</li><li>Соответствующие конфиг поля в <code>vite.config.js</code>, если они есть.</li></ul><p>Pre-bundling должен будет повторно запуститься (re-run) когда один из вышеуказанных пунктов изменится.</p><p>Если по какой-то причине Вы хотите, чтобы Vite пересобрал зависимости (re-bundle deps), Вы можете запустить dev сервер с параметром <code>--force</code> или вручную удалить папку <code>node_modules/.vite</code>.</p><h3 id="browser-cache" tabindex="-1">Browser Cache <a class="header-anchor" href="#browser-cache" aria-hidden="true">#</a></h3><p>Резолвнутые (найденные и обработанные) запросы зависимостей жёстко кэшируются с помощью HTTP заголовков <code>max-age=31536000,immutable</code>, чтобы улучшить производительность перезагрузки страниц во время разработки. Закэшировавшись один раз, эти запросы больше никогда не будут грузиться на dev сервер снова. Они автоматически удалятся из кеша с помощью добавленной версии в query параметрах, если установлена другая версия (как это отражено в вашем package manager lockfile). Если Вы хотите продебажить ваши зависимости при помощи локальных изменений, Вы можете сделать следующее:</p><ol><li>Временно заблокируйте кэш через вкладку Network в devtools браузера;</li><li>Перезапустите Vite dev сервер с флагом <code>--force</code> чтобы пересобрать зависимости (re-bundle the deps);</li><li>Перезагрузите страницу.</li></ol>',25)];a.render=function(n,o,a,c,l,s){return e(),d("div",null,i)};export{o as __pageData,a as default};
